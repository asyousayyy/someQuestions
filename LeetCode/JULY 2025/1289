class Solution {
public:
    // int helper(vector<vector<int>> &grid, int i, int j, vector<vector<int>> &dp){
    //     int n = grid.size();
    //     if(i==n-1) return grid[i][j];
    //     if(i>=n || j>=n || i<0 || j<0) return 0;

    //     if(dp[i][j]!=-1) return dp[i][j];

    //     int next = INT_MAX;

    //     for(int k=0; k<n; k++){
    //         if(k==j) continue;
    //         next = min(next, helper(grid,i+1,k,dp));
    //     }

    //     return dp[i][j] = grid[i][j]+next;
    // }

    int minFallingPathSum(vector<vector<int>>& grid) {
        int n = grid.size();
        vector<int> prev = grid[0];

        int min1 = INT_MAX, min2 = INT_MAX, min1col = -1;
        for(int j=0; j<n; j++){
            if(prev[j] < min1){
                min2 = min1;
                min1 = prev[j];
                min1col = j;
            }
            else if(prev[j] < min2){
                min2 = prev[j];
            }
        }

        //second row onwards
        for(int i=1; i<n; i++){
            vector<int> curr(n);

            for(int j=0; j<n; j++){
                if(j==min1col){
                    curr[j] = grid[i][j] + min2;
                }
                else{
                    curr[j] = grid[i][j] + min1;
                }
            }

            min1 = INT_MAX;
            min2 = INT_MAX;
            min1col = -1;

            for(int j=0; j<n; j++){
                if(curr[j]<min1){
                    min2 = min1;
                    min1 = curr[j];
                    min1col = j;
                }
                else if(curr[j]<min2){
                    min2 = curr[j];
                }
            }

        }

        return min1;
    }
};
